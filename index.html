<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI 光路实验室 v0.8 (修复版)</title>
    <style>
        body {
            margin: 0;
            background-color: #0d1117;
            color: #c9d1d9;
            font-family: 'Consolas', 'Monaco', 'PingFang SC', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
            overflow-y: auto;
            touch-action: pan-y;
            padding: 10px 0;
            box-sizing: border-box;
        }

        /* HUD */
        #hud-container {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            z-index: 10;
            pointer-events: none;
        }
        .hud-box {
            background: rgba(22, 27, 34, 0.85);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            flex: 1 1 auto;
            min-width: 80px;
            text-align: center;
        }
        .hud-label { font-size: 10px; color: #8b949e; margin-bottom: 2px; }
        .hud-value { font-size: 18px; font-weight: bold; color: #58a6ff; font-family: 'Consolas', monospace; }
        .hud-unit { font-size: 12px; color: #8b949e; }
        .highlight-blue { color: #58a6ff; } .highlight-text { color: #f2cc60; }

        /* 画布 */
        #canvas-wrapper {
            position: relative;
            box-shadow: 0 0 50px rgba(88, 166, 255, 0.05);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #30363d;
            width: 95vw;
            max-width: 800px;
            aspect-ratio: 2 / 1;
            margin: 10px 0;
            touch-action: none; /* 关键：画布内禁止浏览器滚动 */
        }
        canvas {
            width: 100%; height: 100%;
            background-image: linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 20px 20px; background-color: #0d1117;
            display: block;
        }

        /* 公式 */
        #formula-bar {
            margin-top: 5px;
            background: #161b22;
            padding: 8px 15px;
            border-radius: 12px;
            border: 1px solid #30363d;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 0 20px rgba(88, 166, 255, 0.1);
            width: 90vw; max-width: 600px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .formula-live { font-family: 'Consolas', monospace; font-size: 16px; color: #c9d1d9; }
        .formula-highlight { color: #58a6ff; font-weight: bold; } .formula-result { color: #f2cc60; font-weight: bold; }

        /* 控制台 */
        #control-panel {
            position: absolute;
            right: 20px;
            top: 20px;
            width: 220px;
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid #58a6ff;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 0 30px rgba(88, 166, 255, 0.2);
            backdrop-filter: blur(10px);
            z-index: 20;
        }
        .control-group { margin-bottom: 12px; }
        .control-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .control-label { font-size: 12px; color: #c9d1d9; }
        .input-smart { width: 50px; background: #0d1117; border: 1px solid #30363d; color: #58a6ff; padding: 2px 5px; border-radius: 4px; font-family: 'Consolas', monospace; font-size: 13px; text-align: right; outline: none; }
        input[type=range] { width: 100%; -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #58a6ff; cursor: pointer; margin-top: -6px; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #30363d; border-radius: 2px; }
        .preset-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; margin-top: 5px; }
        .btn-preset { background: #21262d; border: 1px solid #30363d; color: #c9d1d9; padding: 8px 0; border-radius: 6px; font-size: 11px; cursor: pointer; text-align: center; }

        /* 手机适配 */
        @media (max-width: 850px) {
            body { justify-content: flex-start; padding-top: 10px; height: auto; }
            #hud-container { position: static; width: 95vw; justify-content: space-between; margin-bottom: 15px; }
            #control-panel { position: static; width: 90vw; margin-bottom: 15px; transform: none; box-sizing: border-box; }
            #canvas-wrapper { width: 95vw; }
        }
    </style>
</head>
<body>
    <div id="hud-container">
        <div class="hud-box"><div>焦距(f)</div><div><span id="hud-f" class="hud-value">10.0</span> <span class="hud-unit">cm</span></div></div>
        <div class="hud-box"><div>物距(u)</div><div><span id="val-u" class="hud-value highlight-blue">20.0</span> <span class="hud-unit">cm</span></div></div>
        <div class="hud-box"><div>像距(v)</div><div><span id="val-v" class="hud-value highlight-text">20.0</span> <span class="hud-unit">cm</span></div></div>
        <div class="hud-box" style="flex: 1.5;"><div>性质</div><div id="img-prop-cn" class="hud-value" style="font-size: 14px;">分析中...</div></div>
    </div>

    <div id="control-panel">
        <div class="control-group">
            <div class="control-header"><span class="control-label">焦距 f</span><input type="text" id="input-f" class="input-smart" value="10.0"></div>
            <input type="range" id="slider-f" min="5" max="20" step="0.1" value="10">
        </div>
        <div class="control-group">
            <div class="control-header"><span class="control-label">物距 u</span><input type="text" id="input-u" class="input-smart" value="20.0"></div>
            <input type="range" id="slider-u" min="2" max="50" step="0.1" value="20">
        </div>
        <div class="control-group">
            <div class="preset-grid">
                <button class="btn-preset" onclick="setPreset('camera')">照相机</button>
                <button class="btn-preset" onclick="setPreset('projector')">投影仪</button>
                <button class="btn-preset" onclick="setPreset('magnifier')">放大镜</button>
            </div>
        </div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="opticsCanvas"></canvas>
    </div>

    <div id="formula-bar">
        <div class="formula-live" id="formula-dynamic">Loading...</div>
    </div>

<script>
    const canvas = document.getElementById('opticsCanvas');
    const ctx = canvas.getContext('2d');
    
    function resizeCanvas() {
        const container = document.getElementById('canvas-wrapper');
        // 关键：确保分辨率匹配
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        draw();
    }
    window.addEventListener('resize', resizeCanvas);

    const SCALE = 10;
    let f_cm = 10.0; 
    let f = f_cm * SCALE;
    let objectPos = { x_cm: 20.0, h: 60 };
    let isDragging = false;

    // UI Refs
    const sliderF = document.getElementById('slider-f'); const inputF = document.getElementById('input-f');
    const sliderU = document.getElementById('slider-u'); const inputU = document.getElementById('input-u');
    const hudF = document.getElementById('hud-f'); const formulaDiv = document.getElementById('formula-dynamic');

    // --- 坐标系统核心 ---
    // 将指针事件转换为相对于画布中心透镜的 cm 距离
    function getPointerCm(e) {
        const rect = canvas.getBoundingClientRect();
        // 兼容触摸和鼠标
        const clientX = (e.touches && e.touches.length > 0) ? e.touches[0].clientX : e.clientX;
        
        // 算出在画布内的像素 X
        const x_px = (clientX - rect.left) * (canvas.width / rect.width);
        
        // 画布中心是透镜位置
        const lensX = canvas.width / 2;
        
        // 向左为正（物距）
        return (lensX - x_px) / SCALE;
    }

    // --- 交互逻辑 ---
    function handleStart(e) {
        const u_cm_click = getPointerCm(e);
        
        // 计算 Y 轴点击位置 (像素)
        const rect = canvas.getBoundingClientRect();
        const clientY = (e.touches && e.touches.length > 0) ? e.touches[0].clientY : e.clientY;
        const y_px = (clientY - rect.top) * (canvas.height / rect.height);
        const axisY = canvas.height / 2;

        // 判定点击范围：X轴误差 ±1.5cm，Y轴误差 ±100px
        if (Math.abs(u_cm_click - objectPos.x_cm) < 1.5 && Math.abs(y_px - (axisY - objectPos.h)) < 150) {
            isDragging = true;
        }
    }

    function handleMove(e) {
        if (isDragging) {
            if (e.cancelable) e.preventDefault(); // 防止手机滚动
            
            let newU = getPointerCm(e);
            
            // 限制范围
            const maxU = (canvas.width / 2) / SCALE - 1; // 别拖出屏幕左边
            if (newU < 0.5) newU = 0.5;
            if (newU > maxU) newU = maxU;
            
            objectPos.x_cm = newU;
            
            // 同步UI
            sliderU.value = newU.toFixed(1);
            inputU.value = newU.toFixed(1);
            updateAllUI();
            draw();
        }
    }
    
    function handleEnd(e) { isDragging = false; }

    // 绑定事件
    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    
    canvas.addEventListener('touchstart', handleStart, { passive: false });
    canvas.addEventListener('touchmove', handleMove, { passive: false });
    canvas.addEventListener('touchend', handleEnd);

    // --- UI Update ---
    function updateFromInput(type) {
        if (type === 'f') { let val = parseFloat(inputF.value); if(!isNaN(val)){ f_cm=val; f=f_cm*SCALE; sliderF.value=val; } }
        else { let val = parseFloat(inputU.value); if(!isNaN(val)){ objectPos.x_cm=val; sliderU.value=val; } }
        updateAllUI(); draw();
    }
    function updateFromSlider(type) {
        if (type === 'f') { f_cm=parseFloat(sliderF.value); f=f_cm*SCALE; inputF.value=f_cm.toFixed(1); }
        else { objectPos.x_cm=parseFloat(sliderU.value); inputU.value=objectPos.x_cm.toFixed(1); }
        updateAllUI(); draw();
    }
    inputF.addEventListener('input', ()=>updateFromInput('f')); inputU.addEventListener('input', ()=>updateFromInput('u'));
    sliderF.addEventListener('input', ()=>updateFromSlider('f')); sliderU.addEventListener('input', ()=>updateFromSlider('u'));

    function setPreset(type) {
        if(type=='camera'){f_cm=10; objectPos.x_cm=30;}
        else if(type=='projector'){f_cm=10; objectPos.x_cm=15;}
        else{f_cm=10; objectPos.x_cm=5;}
        f=f_cm*SCALE; sliderF.value=f_cm; inputF.value=f_cm.toFixed(1);
        sliderU.value=objectPos.x_cm; inputU.value=objectPos.x_cm.toFixed(1);
        updateAllUI(); draw();
    }

    function updateAllUI() {
        hudF.innerText = f_cm.toFixed(1);
        const u = objectPos.x_cm;
        let v_disp = "∞";
        if (Math.abs(u - f_cm) > 0.1) {
            const v = (f_cm * u) / (u - f_cm);
            v_disp = Math.abs(v).toFixed(1);
        }
        formulaDiv.innerHTML = `1/<span class="formula-highlight">${f_cm.toFixed(1)}</span> = 1/<span class="formula-highlight">${u.toFixed(1)}</span> + 1/<span class="formula-result">${v_disp}</span>`;
    }

    // --- Draw ---
    function draw() {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        const lx = canvas.width/2; const ly = canvas.height/2;
        // 动态高度，适应手机
        const h = objectPos.h * (canvas.height/400);

        // Grid & Axis
        ctx.beginPath(); ctx.strokeStyle='#30363d'; ctx.lineWidth=2; ctx.moveTo(0,ly); ctx.lineTo(canvas.width,ly); ctx.stroke();
        ctx.fillStyle='#8b949e'; ctx.font='12px Consolas';
        [-2*f, -f, f, 2*f].forEach((p,i)=>{ const px=lx+p; ctx.beginPath(); ctx.arc(px,ly,3,0,Math.PI*2); ctx.fill(); ctx.fillText(['2F','F','F','2F'][i], px-5, ly+20); });

        // Lens
        ctx.shadowBlur=15; ctx.shadowColor='rgba(88,166,255,0.6)'; ctx.strokeStyle='#58a6ff'; ctx.lineWidth=3;
        ctx.beginPath(); ctx.ellipse(lx,ly,8,canvas.height*0.35,0,0,Math.PI*2); ctx.stroke(); ctx.shadowBlur=0;

        // Calc
        const u_px = objectPos.x_cm * SCALE;
        let v_px=0, imgH=0, isVirt=false;
        if(Math.abs(u_px-f)<0.5) v_px=Infinity;
        else {
            v_px = (f*u_px)/(u_px-f);
            const M = v_px/u_px; imgH=h*M;
            if(u_px<f) isVirt=true;
        }

        // Object
        drawArrow(lx-u_px, ly, h, '#3fb950', '物体');
        
        // Image
        if(v_px!==Infinity) {
            const col = isVirt?'#d2a8ff':'#f2cc60';
            ctx.save(); if(isVirt)ctx.setLineDash([5,5]);
            drawArrow(lx+v_px, ly, -imgH, col, isVirt?'虚像':'实像');
            ctx.restore();
        }

        // HUD Text Update
        const pCn = document.getElementById('img-prop-cn');
        const valV = document.getElementById('val-v');
        document.getElementById('val-u').innerText = objectPos.x_cm.toFixed(1);
        if(v_px===Infinity) { valV.innerText="∞"; pCn.innerText="不成像"; pCn.style.color="#8b949e"; }
        else {
            valV.innerText = Math.abs(v_px/SCALE).toFixed(1);
            if(isVirt) { pCn.innerText="正立·放大·虚像"; pCn.style.color="#d2a8ff"; }
            else {
                let s = (Math.abs(Math.abs(v_px)-u_px)<1)?"等大":(Math.abs(v_px)>u_px)?"放大":"缩小";
                pCn.innerText=`倒立·${s}·实像`; pCn.style.color="#f2cc60";
            }
        }

        // Rays
        ctx.lineWidth=1; ctx.strokeStyle='rgba(88,166,255,0.4)';
        // 1. Parallel -> F
        ctx.beginPath(); ctx.moveTo(lx-u_px, ly-h); ctx.lineTo(lx, ly-h); ctx.lineTo(lx+f*10, ly+(h)*10); ctx.stroke();
        // 2. Center
        ctx.beginPath(); ctx.moveTo(lx-u_px, ly-h); 
        const slope = (ly-(ly-h))/(lx-(lx-u_px)); // h/u_px
        ctx.lineTo(lx+1000, ly+1000*slope); ctx.stroke();
        
        if(isVirt) {
             ctx.save(); ctx.setLineDash([4,6]); ctx.strokeStyle='rgba(210,168,255,0.3)';
             ctx.beginPath(); ctx.moveTo(lx, ly-h); ctx.lineTo(lx+v_px, ly+imgH); 
             ctx.moveTo(lx, ly); ctx.lineTo(lx+v_px, ly+imgH); ctx.stroke(); ctx.restore();
        }
    }

    function drawArrow(x, y, h, col, txt) {
        ctx.shadowBlur=10; ctx.shadowColor=col; ctx.strokeStyle=col; ctx.fillStyle=col; ctx.lineWidth=4; ctx.lineCap='round';
        ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x,y-h); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x,y-h); ctx.lineTo(x-6,y-h+(h>0?10:-10)); ctx.lineTo(x+6,y-h+(h>0?10:-10)); ctx.fill(); ctx.shadowBlur=0;
        ctx.font='bold 14px Consolas'; ctx.textAlign='center'; ctx.fillText(txt, x, y-h-(h>0?15:-25)); ctx.textAlign='start';
    }

    // Init
    setTimeout(()=>{resizeCanvas(); updateAllUI();}, 100);
</script>
</body>
</html>
